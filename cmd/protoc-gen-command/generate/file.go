package generate

import (
	"bytes"

	"strings"

	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/plugin"
	"github.com/pkg/errors"
)

const (
	content = `// Code generated by snapsource. DO NOT EDIT.
// source: {{ .Source }}

package {{ .Package }}
{{ range .Commands }}

// AggregateID implements the snapsource.Command interface for {{ .Name }}
func (c *{{ .Name }}) AggregateID() string {
	return c.{{ id . }}
}
{{ end }}
`
)

func isCommand(in *descriptor.DescriptorProto) bool {
	for _, field := range in.Field {
		if strings.ToLower(*field.Name) == "id" {
			return true
		}
	}
	return false
}

func selectCommands(in []*descriptor.DescriptorProto) []*descriptor.DescriptorProto {
	commands := make([]*descriptor.DescriptorProto, 0, len(in))

	for _, item := range in {
		if isCommand(item) {
			commands = append(commands, item)
		}
	}

	return commands
}

// File accepts the proto file definition and returns the response for this file
func File(in *descriptor.FileDescriptorProto) (*plugin_go.CodeGeneratorResponse_File, error) {
	pkg, err := packageName(in)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to determine package name for file, %v", *in.Name)
	}

	buf := bytes.NewBuffer(nil)
	t, err := newTemplate(content)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to construct template for file, %v", *in.Name)
	}

	t.Execute(buf, map[string]interface{}{
		"Source":   *in.Name,
		"Package":  pkg,
		"Commands": selectCommands(in.MessageType),
	})

	return &plugin_go.CodeGeneratorResponse_File{
		Name:    filename(in),
		Content: String(buf.String()),
	}, nil
}

// AllFiles accepts multiple proto file definitions and returns the list of files
func AllFiles(in []*descriptor.FileDescriptorProto) ([]*plugin_go.CodeGeneratorResponse_File, error) {
	results := make([]*plugin_go.CodeGeneratorResponse_File, 0, len(in))

	ignored := []string{
		"google/protobuf/descriptor.proto",
		"github.com/gogo/protobuf/gogoproto/gogo.proto",
	}

	if in != nil {
	loop:
		for _, file := range in {
			for _, ignore := range ignored {
				if *file.Name == ignore {
					continue loop
				}
			}

			v, err := File(file)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			results = append(results, v)
		}
	}

	return results, nil
}
