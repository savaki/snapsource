package generate

import (
	"bytes"

	"strings"

	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/plugin"
	"github.com/pkg/errors"
)

const (
	content = `// Code generated by snapsource. DO NOT EDIT.
// source: {{ .Source }}{{ $Events := .Events }}

package {{ .Package }}

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"time"

	"github.com/savaki/snapsource"
	"github.com/gogo/protobuf/proto"
)

type Serializer struct {
}

func (s Serializer) MarshalEvent(event snapsource.Event) ([]byte, error) {
	return MarshalEvent(event)
}

func (s Serializer) UnmarshalEvent(data []byte) (snapsource.Event, error) {
	return UnmarshalEvent(data)
}

func NewSerializer() snapsource.Serializer {
	return Serializer{}
}
{{ range .Fields }}
func (m *{{ .TypeName | base | camel }}) AggregateID() string { return m.{{ id .TypeName $Events }} }
func (m *{{ .TypeName | base | camel }}) EventVersion() int   { return int(m.Version) }
func (m *{{ .TypeName | base | camel }}) EventAt() time.Time  { return time.Unix(m.At, 0) }
{{ end }}

func MarshalEvent(event snapsource.Event) ([]byte, error) {
	payload := &{{ .Message.Name | base | camel }}{}

	switch v := event.(type) {
{{ range .Fields }}
	case *{{ .TypeName | base | camel }}:
		payload.Type = {{ .Number }}
		payload.{{ .Name | camel }} = v
{{ end }}
	default:
		return nil, fmt.Errorf("Unhandled type, %v", event)
	}

	data, err := proto.Marshal(payload)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func UnmarshalEvent(data []byte) (snapsource.Event, error) {
	container := &{{ .Message.Name | base | camel }}{};
	err := proto.Unmarshal(data, container)
	if err != nil {
		return nil, err
	}

	var event interface{}
	switch container.Type {
{{ range .Fields }}
	case {{ .Number }}:
		event = container.{{ .Name | camel }}
{{ end }}
	default:
		return nil, fmt.Errorf("Unhandled type, %v", container.Type)
	}

	return event.(snapsource.Event), nil
}

type Encoder struct{
	w io.Writer
}

func (e *Encoder) WriteEvent(event snapsource.Event) (int, error) {
	data, err := MarshalEvent(event)
	if err != nil {
		return 0, err
	}

	// Write the length of the marshaled event as uint64
	//
	buffer := make([]byte, 8)
	binary.LittleEndian.PutUint64(buffer, uint64(len(data)))
	if _, err := e.w.Write(buffer); err != nil {
		return 0, err
	}

	n, err := e.w.Write(data)
	if err != nil {
		return 0, err
	}

	return n + 8, nil
}

func NewEncoder(w io.Writer) *Encoder {
	return &Encoder{
		w: w,
	}
}

type Decoder struct {
	r       *bufio.Reader
	scratch *bytes.Buffer
}

func (d *Decoder) readN(n uint64) ([]byte, error) {
	d.scratch.Reset()
	for i := uint64(0); i < n; i++ {
		b, err := d.r.ReadByte()
		if err != nil {
			return nil, err
		}
		if err := d.scratch.WriteByte(b); err != nil {
			return nil, err
		}
	}
	return d.scratch.Bytes(), nil
}

func (d *Decoder) ReadEvent() (snapsource.Event, error) {
	data, err := d.readN(8)
	if err != nil {
		return nil, err
	}
	length := binary.LittleEndian.Uint64(data)

	data, err = d.readN(length)
	if err != nil {
		return nil, err
	}

	event, err := UnmarshalEvent(data)
	if err != nil {
		return nil, err
	}

	return event, nil
}

func NewDecoder(r io.Reader) *Decoder {
	return &Decoder {
		r:       bufio.NewReader(r),
		scratch: bytes.NewBuffer(nil),
	}
}

type Builder struct {
	id      string
	version int32
	Events  []snapsource.Event
}

func NewBuilder(id string, version int) *Builder {
	return &Builder {
		id:      id,
		version: int32(version),
	}
}

func (b *Builder) nextVersion() int32 {
	b.version++
	return b.version
}

{{ range .Events }}
func (b *Builder) {{ .Name | camel }}({{ range .Field | other }}{{ .Name | camel | lower }} {{ . | type }}, {{ end }}) {
	event := &{{ .Name | camel }}{
		{{ id .Name $Events }}:      b.id,
		Version: b.nextVersion(),
		At:      time.Now().Unix(),
{{ range .Field | other }}	{{ . | name }}: {{ . | name | lower }},
{{ end }}
	}
	b.Events = append(b.Events, event)
}
{{ end }}
`
)

func isEventType(proto *descriptor.DescriptorProto) bool {
	var (
		hasID      bool
		hasAt      bool
		hasVersion bool
	)

	for _, field := range proto.Field {
		if field.Name == nil {
			continue
		}
		switch strings.ToLower(*field.Name) {
		case "id":
			hasID = true
		case "at":
			hasAt = true
		case "version":
			hasVersion = true
		}
	}

	return hasID && hasAt && hasVersion
}

// File accepts the proto file definition and returns the response for this file
func File(in *descriptor.FileDescriptorProto) (*plugin_go.CodeGeneratorResponse_File, error) {
	pkg, err := packageName(in)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to determine package name for file, %v", *in.Name)
	}

	message, err := findContainerMessage(in)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to find messages for file, %v", *in.Name)
	}
	if message == nil {
		return nil, nil
	}

	events := make([]*descriptor.DescriptorProto, 0, len(in.MessageType))
	for _, m := range in.MessageType {
		if m == message {
			continue
		}
		if !isEventType(m) {
			continue
		}
		events = append(events, m)
	}

	buf := bytes.NewBuffer(nil)
	t, err := newTemplate(content)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to construct template for file, %v", *in.Name)
	}

	t.Execute(buf, map[string]interface{}{
		"Source":      *in.Name,
		"Package":     pkg,
		"Message":     message,
		"MessageType": in.MessageType,
		"Fields":      message.Field[1:],
		"Events":      events,
	})

	return &plugin_go.CodeGeneratorResponse_File{
		Name:    filename(in),
		Content: String(buf.String()),
	}, nil
}

// AllFiles accepts multiple proto file definitions and returns the list of files
func AllFiles(in []*descriptor.FileDescriptorProto) ([]*plugin_go.CodeGeneratorResponse_File, error) {
	results := make([]*plugin_go.CodeGeneratorResponse_File, 0, len(in))

	if in != nil {
		for _, file := range in {
			v, err := File(file)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			results = append(results, v)
		}
	}

	return results, nil
}
